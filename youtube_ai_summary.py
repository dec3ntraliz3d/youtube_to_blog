import argparse
import logging
import re
import sys
from urllib.parse import urlparse, parse_qs

from youtube_transcript_api import YouTubeTranscriptApi
from ollama import chat, ChatResponse
from pytubefix import YouTube

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


def get_video_title(url: str) -> str:
    """
    Retrieve the title of the YouTube video using pytubefix.
    
    Args:
        url (str): URL of the YouTube video.
    
    Returns:
        str: The title of the video.
    """
    yt = YouTube(url)
    return yt.title


def extract_video_id(url: str) -> str:
    """
    Extract the video ID from a YouTube URL.
    
    Supports standard, embed, and shortened URL formats.
    
    Args:
        url (str): The YouTube video URL.
    
    Returns:
        str: The extracted video ID, or None if extraction fails.
    """
    parsed_url = urlparse(url)
    video_id = None

    if parsed_url.netloc in ['youtu.be', 'www.youtu.be']:
        # Shortened URL format: https://youtu.be/<video_id>
        video_id = parsed_url.path.lstrip("/")
    elif parsed_url.netloc in ['youtube.com', 'www.youtube.com']:
        if "embed" in parsed_url.path:
            # Embed URL format: https://www.youtube.com/embed/<video_id>
            parts = parsed_url.path.split("/")
            if len(parts) >= 3:
                video_id = parts[2]
        elif "/watch" in parsed_url.path:
            # Standard URL format: https://www.youtube.com/watch?v=<video_id>
            query_params = parse_qs(parsed_url.query)
            video_id_list = query_params.get("v")
            if video_id_list:
                video_id = video_id_list[0]
    
    return video_id


def get_transcript(url: str):
    """
    Retrieve the transcript for a YouTube video.
    
    Args:
        url (str): The YouTube video URL.
    
    Returns:
        list: Transcript entries as returned by YouTubeTranscriptApi.
    
    Raises:
        ValueError: If video ID extraction fails.
    """
    video_id = extract_video_id(url)
    if not video_id:
        raise ValueError("Invalid YouTube URL: unable to extract video ID.")
    
    logger.info(f"Fetching transcript for video ID: {video_id}")
    return YouTubeTranscriptApi.get_transcript(video_id)


def extract_text(transcript: list) -> str:
    """
    Concatenate transcript entries into a single string.
    
    Args:
        transcript (list): List of transcript entries.
    
    Returns:
        str: The cleaned transcript text.
    """
    return " ".join(chunk["text"] for chunk in transcript).strip()


def summarize_text(text: str) -> str:
    """
    Summarize the transcript into a well-structured blog post using an LLM.
    
    Uses Ollama's chat model to generate a formatted blog post.
    
    Args:
        text (str): The raw transcript text.
    
    Returns:
        str: The blog post content generated by the LLM.
    """
    logger.info("Summarizing text using LLM...")

    prompt = (
        "Convert this YouTube video transcript into a well-structured blog post.\n"
        "Follow these guidelines:\n"
        "1. Add a clear introduction and conclusion.\n"
        "2. Organize content into logical sections with headings.\n"
        "3. Improve flow and readability while maintaining the original message.\n"
        "4. Add appropriate markdown formatting.\n"
        "5. Keep the tone professional but engaging.\n\n"
        "Here's the transcript:\n"
        f"{text}"
    )
    
    response: ChatResponse = chat(
        model="deepseek-r1:7B",
        messages=[
            {"role": "user", "content": prompt},
        ]
    )
    
    llm_response = response["message"]["content"]
    # Remove any unwanted tokens (e.g., <think> ... </think>)
    cleaned_response = re.sub(r"<think>.*?</think>", "", llm_response, flags=re.DOTALL).strip()
    return cleaned_response


def main():
    """
    Main function to fetch YouTube video details, transcript, and generate a blog post.
    
    The blog post is saved as a Markdown (.md) file named after the video title.
    """
    parser = argparse.ArgumentParser(
        description="Summarize youtube videos with AI ."
    )
    parser.add_argument("url", help="The URL of the YouTube video")
    args = parser.parse_args()
    url = args.url

    try:
        logger.info("Fetching video title from YouTube...")
        title = get_video_title(url)

        logger.info("Fetching transcript from YouTube...")
        transcript = get_transcript(url)
        cleaned_transcript_text = extract_text(transcript)

        # logger.info("Creating blog post using AI...")
        blog_post = summarize_text(cleaned_transcript_text)

        # Ensure the title is safe for use as a filename
        safe_title = re.sub(r'[\\/*?:"<>|]', "", title)
        filename = f"{safe_title}.md"

        with open(filename, "w", encoding="utf-8") as f:
            f.write(blog_post)

        logger.info(f"Summary '{filename}' created successfully!")
    except Exception as e:
        logger.error(f"An error occurred: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
